apiVersion: apps/v1   // api for Depployment apps/v1 can't change 
kind: Deployment   // Deployments, StatefulSets, DaemonSets, etc.
metadata:   // giving details for deployment for reference  as name and lables 
  name: frontend-django
  labels:    key value pair it works  Deployment : key value and value is labels if you want to add this deployment to any other yaml file we use labels as reference perpose 
    app: frontend-django      
spec:  //  what deployment need to do work 
  replicas: 1  // means only one pod will be running
  selector:    // Selector defines how the Deployment finds which pods it manages.
    matchLabels:    //It looks for pods with label app: frontend-django. This must match the labels on pod templates.
      app: frontend-django  
  template:  // for pod create down hare || The template describes the pods that will be created. || for pod Reference 
    metadata:  //The pod template has its own metadata with labels. Here, pods created by this Deployment will have the label app: frontend-django, matching the selector above.
      labels:
        app: frontend-django
    spec:    // what pod need to do work 
      containers: //container is defined with the name frontend-django.
        - name: frontend-django
          image: madeep2669/django-frontend:10  // docker image  : 10 means version 
          imagePullPolicy: Always   // pull the image from the registry when creating a new pod. form DockerHub 
          ports:
            - containerPort: 3001   // network ports the container exposes.internally
          env:  // environment variables inside the container.
            - name: REACT_APP_API_URL //REACT_APP_API_URL is set to a URL that points to a backend Django service inside the Kubernetes cluster.
            *****This environment variable could be used by the frontend app to connect to the backend API.****
              value: "http://django-service.django.svc.cluster.local:8000"
          resources: //resource requests and limits for the container.
            requests: // minimum resources guaranteed to the container.
              cpu: "500m"
              memory: "256Mi"
            limits:  // maximum resources the container can use.
              cpu: "1000m"
              memory: "512Mi"
---
apiVersion: v1  //This is a core Kubernetes resource, so API version is v1
kind: Service
metadata: // giving details for service for reference  as name and lables 
  name: frontend-django-service  //This is how other pods or services will refer to it. 
spec:  what service need to do work
  type: ClusterIP  //The Service type is ClusterIP, meaning it is reachable only within the Kubernetes cluster on a virtual IP.
  selector:  // Selector defines how the service finds which pods it manages.  //The service will route traffic to pods with the label app: frontend-django.
    app: frontend-django  //Matches the pods created by the Deployment above
  ports:
    - port: 80
      targetPort: 3001 //Inside the pod, the frontend app listens on port 3001 (containerPort: 3001 but Service exposes port 80 inside the cluster. //** forwards that traffic to port 3001 
      protocol: TCP  // specifies the network protocol.

 ðŸ”¼ Scale Up Behavior Explained

| Line                             | Meaning                                                                                                                        |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `stabilizationWindowSeconds: 30` | **Wait 30 seconds** before scaling up again, to avoid reacting too quickly to short spikes in usage.                           |
| `type: Pods` + `value: 2`        | **At most 2 pods** can be added every 30 seconds.                                                                              |
| `selectPolicy: Max`              | If there are multiple policies, **choose the one that allows more pods** to be added. (In this case, thereâ€™s only one policy.) |

âœ… Example:
Letâ€™s say:

Your deployment has 1 pod running.

Suddenly, CPU usage goes very high and HPA decides it needs 5 pods.

Hereâ€™s what happens:

Initial scale-up: 1 âžœ 3 pods (added 2 pods as per policy)

Wait 30 seconds

If high usage continues: 3 âžœ 5 pods (adds 2 more pods)

ðŸ“Œ It will not add all 4 pods at once, even if needed. It limits the scaling to 2 pods per 30 seconds.

This avoids overloading your cluster and gives time to observe if the CPU spike is real or temporary.


___________________________________________________________________________________________________________

ðŸ”½ Scale Down Behavior (Easy Explanation)

| Line                             | Meaning                                                                                               |
| -------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `stabilizationWindowSeconds: 60` | **Wait 60 seconds** before scaling down again, to avoid reacting too quickly to small drops in usage. |
| `type: Percent` + `value: 50`    | In one go, **you can reduce up to 50%** of the current pods.                                          |
| `type: Pods` + `value: 1`        | Or, **you can remove 1 pod** at a time.                                                               |
| `selectPolicy: Max`              | Between 50% and 1 pod, **choose the option that removes more pods**.                                  |


âœ… Example:
If you have 4 pods running:

50% of 4 = 2 pods

1 pod = 1

Since selectPolicy: Max, it chooses 2 pods to remove.

This setup gives you control and safety when scaling down â€” it won't suddenly remove too many pods or respond too fast to a temporary drop.


